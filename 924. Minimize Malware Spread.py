class unionFind():
    def __init__(self, num):
        self.parents = [i for i in range(num)]
        self.size = [1 for _ in range(num)]

    def find(self, val):
        if self.parents[val] != val:
            self.parents[val] = self.find(self.parents[val]) # create shortcut
        return self.parents[val]
    
    def union(self, num1, num2):
        root1 = self.find(num1)
        root2 = self.find(num2)
        if root1 != root2: # union
            self.parents[root1] = root2
            self.size[root2] += self.size[root1]

class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        # if initial i and j can affect the same node x -> they finaly affect the same set of nodes
        # then find in initial that afect the maximum number of nodes (otherwise return minimal index)
        n = len(graph)
        uf = unionFind(n)
        initial.sort()

        for i in range(n):
            for j in range(i + 1, n):
                if graph[i][j] == 1:
                    uf.union(i, j)
        
        sizes = dict.fromkeys(initial, 0)
        roots = defaultdict(list) # root, num
        maxSize = 1
        maxSizeIdx = initial[0]

        # initial.sort()
        for ini in initial:
            root = uf.find(ini)
            roots[root].append(ini) 
            sizes[ini] = uf.size[root]
            
        # only remove when not in same root
        candidates = []
        for key, val in roots.items():
            if len(val) == 1: # only one
                candidates.append(val[0])

        if not candidates: # no
            return initial[0]
        else:
            maxSize = 0
            maxSizeIdx = candidates[0]
            for i in candidates:
                if sizes[i] > maxSize:
                    maxSize = sizes[i]
                    maxSizeIdx = i
            return maxSizeIdx
        