class unionFind():
    def __init__(self, num):
        self.parents = [i for i in range(num)]
        self.size = [1 for _ in range(num)]

    def find(self, val):
        if self.parents[val] != val:
            self.parents[val] = self.find(self.parents[val]) # create shortcut
        return self.parents[val]
    
    def union(self, num1, num2):
        root1 = self.find(num1)
        root2 = self.find(num2)
        if root1 != root2: # union
            self.parents[root1] = root2
            self.size[root2] += self.size[root1]

class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        # for ini in initial, test merge removing it, get minimal malware infect size
        n = len(graph)
        affects = dict.fromkeys(initial, 0)
        initial.sort()

        for ini in initial: # disable ini
            uf = unionFind(n)
            for i in range(n):
                if i == ini:
                    continue
                for j in range(i + 1, n):
                    if j == ini:
                        continue
                    if graph[i][j] == 1:
                        uf.union(i, j)
            same_root = []
            for i in initial:
                if i == ini:
                    continue
                root = uf.find(i)
                if root not in same_root:
                    affects[ini] += uf.size[root]
                    same_root.append(root)
        
        # find minimal affect
        minVal = 1000
        minIdx = -1
        for k, v in affects.items():
            if v < minVal:
                minIdx = k
                minVal = v
            elif v == minVal and k < minIdx:
                minIdx = k
        
        return minIdx
 
        